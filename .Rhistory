dens=density(err)
plot(dens$x,dens$y,type='l') #response variable is not normal (i.e., it is bimodal)!
set.seed(1)
b0=1 #regression coefficients
b1=3 #regression coefficients
n=100 #number of observations
x=c(rep(0,n/2),rep(1,n/2))     #covariate (0=men, 1=women)
mean1=b0+b1*x
y=rnorm(n,mean=mean1,sd=0.5) #response variable
data1=data.frame(x=x,y=y)
#plot distribution of response variable
dens=density(data1$y)
plot(dens$x,dens$y,type='l') #response variable is not normal (i.e., it is bimodal)!
#plot distribution of error term
mod=lm(y~x,data=data1)
head(mod)
mod=lm(y~x,data=data1)
dens=density(mod$residuals)
plot(dens$x,dens$y,type='l') #error term seems to have a normal distribution
library(car)
library(MVA)
library(MASS)
library(meifly)
usAir<-USairpollution
sulfMod<-lm(SO2~manu+temp+predays+precip+wind+popul, data=usAir)
extractAIC(sulfMod)y<- usAir$SO2x<- usAir[,-1];xmods<- fitall(y,x,'lm')
extractAIC(sulfMod)
y<- usAir$SO2
x<- usAir[,-1];
xmods<- fitall(y,x,'lm')
summary(xmods)
str(xmods)
?fitall
summary(xmods)
z=summary(xmods)
head(z)
which(z$AIC==min(z$AIC))
z=summary(xmods)
which(z$AIC==min(z$AIC))
z[24,]
xmods[[24]]
ind=which(z$AIC==min(z$AIC))
z[ind,]
xmods[[ind]]
summary(xmods[[ind]])
2^6
z
ind
xmods[[ind]]
summary(xmods[[ind]])
z[order(z$AIC),]
set.seed(1)
n=100
habitat.type=sample(1:8,size=n,replace=T)
xmat=matrix(0,7)
colnames(xmat)=paste('x',1:7,sep='')
for (i in 1:7){ #habitat type 8 is the baseline habitat type
cond=habitat.type==i
xmat[cond,i]=1
}
unique(cbind(xmat,habitat.type))
set.seed(1)
n=100
habitat.type=sample(1:8,size=n,replace=T)
xmat=matrix(0,n,7)
colnames(xmat)=paste('x',1:7,sep='')
for (i in 1:7){ #habitat type 8 is the baseline habitat type
cond=habitat.type==i
xmat[cond,i]=1
}
unique(cbind(xmat,habitat.type))
set.seed(1)
n=100
habitat.type=sort(sample(1:8,size=n,replace=T))
xmat=matrix(0,n,7)
colnames(xmat)=paste('x',1:7,sep='')
for (i in 1:7){ #habitat type 8 is the baseline habitat type
cond=habitat.type==i
xmat[cond,i]=1
}
unique(cbind(xmat,habitat.type))
?chisq.test
14*6
rm(list=ls(all=TRUE))
set.seed(123)
nobs=500
#sine function
x1=seq(from=0,to=2*pi,length.out=nobs)
y1=exp(sin(x1)); round(range(y1),2)
plot(x1,y1)
#function that asymptotes
a=3
x2=seq(from=-10,to=10,length.out=nobs)
x2=sample(x2,size=nobs,replace=F)
prob=exp(x2)/(1+exp(x2)); mean(prob)
prob=prob-mean(prob)
y2=exp(a*prob); round(range(y2),2)
plot(x2,y2)
rm(list=ls(all=TRUE))
library('Rcpp')
set.seed(1)
setwd('U:\\GIT_models\\git_mixture')
source('mixture gibbs functions.R')
sourceCpp('aux1.cpp')
source('mixture gibbs main function.R')
ngibbs=1000
dat=data.matrix(read.csv('fake data.csv',as.is=T))
ngroup=50
nburnin=ngibbs/2
one.minus.dat=1-dat
#useful settings
nloc=nrow(dat)
nspp=ncol(dat)
#initial parameter values
z=sample(1:ngroup,size=nloc,replace=T)
theta=rep(1/ngroup,ngroup)
tmp=runif(ngroup*nspp)
phi=matrix(tmp,ngroup,nspp)
gamma1=0.1
gamma.possib=seq(from=0.1,to=1,by=0.05)
#to store results from gibbs sampler
store.phi=matrix(NA,ngibbs,nspp*ngroup)
store.theta=matrix(NA,ngibbs,ngroup)
store.z=matrix(NA,ngibbs,nloc)
store.gamma=matrix(NA,ngibbs,1)
store.logl=rep(NA,ngibbs)
z=update.z(dat=dat,one.minus.dat=one.minus.dat,
phi=phi,theta=theta,
ngroup=ngroup,nloc=nloc,nspp=nspp)
#summarize data
tmp=ncs(dat=dat,z=z-1,nspp=nspp,nloc=nloc,ngroup=ngroup)
phi=matrix(rbeta(ngroup*nspp,tmp$ncs1+1,tmp$ncs0+1),ngroup,nspp)
tmp=update.theta(z=z,ngroup=ngroup,gamma1=gamma1,burnin=burnin,gibbs.step=i,theta=theta)
theta=tmp$theta
z=tmp$z
v=tmp$v
i=1
tmp=update.theta(z=z,ngroup=ngroup,gamma1=gamma1,burnin=burnin,gibbs.step=i,theta=theta)
theta=tmp$theta
z=tmp$z
v=tmp$v
burnin=ngibbs/2
tmp=update.theta(z=z,ngroup=ngroup,gamma1=gamma1,burnin=burnin,gibbs.step=i,theta=theta)
theta=tmp$theta
z=tmp$z
v=tmp$v
head(theta)
gamma=sample.gamma(v=v,ngroup=ngroup,gamma.possib=gamma.possib)
sample.gamma(v=v,ngroup=ngroup,gamma.possib=gamma.possib)
rm(list=ls(all=TRUE))
library('Rcpp')
set.seed(1)
setwd('U:\\GIT_models\\git_mixture')
source('mixture gibbs functions.R')
sourceCpp('aux1.cpp')
source('mixture gibbs main function.R')
ngibbs=1000
dat=data.matrix(read.csv('fake data.csv',as.is=T))
res=mixture.gibbs.main.func(dat=dat,ngroup=50,ngibbs=ngibbs,burnin=ngibbs/2)
rm(list=ls(all=TRUE))
set.seed(2)
library('mvtnorm')
library('Rcpp')
setwd('U:\\GIT_models\\git_cluster_rcurve_gamma')
source('gibbs functions.R')
sourceCpp('aux1.cpp')
source('gibbs clust response curve gamma.R')
ngroups=32
gamma=0.1
ngibbs=1000
nome=paste0('fake ',c('data ','xmat '),'sim ',ngroups,'ng','.csv')
y=data.matrix(read.csv(nome[1],as.is=T))
xmat=data.matrix(read.csv(nome[2],as.is=T))
ngroups=50
burnin=ngibbs/2
t.xmat=t(xmat)
xtx=t.xmat%*%xmat
#useful stuff
nloc=nrow(y)
nspp=ncol(y)
nparam=ncol(xmat)
gamma.possib=seq(from=0.1,to=1,by=0.05)
#get invSigma, Sigma, lds for different values of n_k
InvSigma.precalc=xtx+diag(1,nparam)
Sigma.precalc=solve(InvSigma.precalc)
lds=determinant(Sigma.precalc)$modulus[1] #log of determinant of covariance matrix
#initial parameter values
betas=matrix(0,nparam,ngroups)
alpha=rep(0,nspp)
omega=matrix(-1,nloc,nspp)
omega[y==1]=1
cs=sample(1:ngroups,size=nspp,replace=T)
theta=rep(1/ngroups,ngroups)
gamma=0.1
#gibbs stuff
vec.betas=matrix(NA,ngibbs,nparam*ngroups)
vec.alpha=matrix(NA,ngibbs,nspp)
vec.theta=matrix(NA,ngibbs,ngroups)
vec.logl=matrix(NA,ngibbs,1)
vec.gamma=rep(NA,ngibbs,1)
vec.cs=matrix(NA,ngibbs,nspp)
q1=nloc*log(2*pi)
alpha1=matrix(alpha,nloc,nspp,byrow=T)
err=omega-alpha1
q2s=colSums(err^2)
q3k=-2*log(theta)
q4s=t(xmat)%*%err
resto.media=xmat%*%betas
dim(omega)
dim(resto.media)
i=1
omega1=matrix(omega[,i],nloc,ngroups)
media1=alpha[i]+resto.media
lprob.norm=colSums(dnorm(omega1,mean=media1,sd=1,log=T))
lprob.norm
head(omega1)
cs=sample.cs(ngroups=ngroups,omega=omega,xmat=xmat,alpha=alpha,betas=betas,theta=theta,
nspp=nspp,nloc=nloc,InvSigma.precalc=InvSigma.precalc,
Sigma.precalc=Sigma.precalc,lds=lds,cs=cs,nparam=nparam)
# cs=cs.true
betas=sample.betas(ngroups=ngroups,cs=cs,nparam=nparam,xtx=xtx,t.xmat=t.xmat,alpha=alpha,
nloc=nloc,nspp=nspp,omega=omega)
# betas=cbind(betas.true,matrix(0,nparam,ngroups-ncol(betas.true)))
omega=sample.omega(y=y,nspp=nspp,nloc=nloc,xmat=xmat,betas=betas,cs=cs,alpha=alpha)
# omega=omega.true
alpha=sample.alpha(nloc=nloc,xmat=xmat,betas=betas,omega=omega,cs=cs,nspp=nspp)
# alpha=alpha.true
tmp=sample.theta(cs=cs,ngroups=ngroups,gamma=gamma,burnin=burnin,gibbs.step=i,
betas=betas,theta=theta)
betas=tmp$betas
cs=tmp$cs
theta=tmp$theta
v=tmp$v[-ngroups]
# theta=rep(1/ngroups,ngroups)
q1=nloc*log(2*pi)
alpha1=matrix(alpha,nloc,nspp,byrow=T)
err=omega-alpha1
q2s=colSums(err^2)
q3k=-2*log(theta)
q4s=t(xmat)%*%err
resto.media=xmat%*%betas
i=1
omega1=matrix(omega[,i],nloc,ngroups)
media1=alpha[i]+resto.media
lprob.norm=colSums(dnorm(omega1,mean=media1,sd=1,log=T))
head(omega1)
tab=table(cs)
tab
tab=rep(NA,ngroups)
tmp=table(cs)
tab[as.numeric(names(tmp))]=tmp
tab
as.numeric(names(tmp))
q1=nloc*log(2*pi)
alpha1=matrix(alpha,nloc,nspp,byrow=T)
err=omega-alpha1
q2s=colSums(err^2)
q3k=-2*log(theta)
q4s=t(xmat)%*%err
resto.media=xmat%*%betas
i=1
omega1=matrix(omega[,i],nloc,ngroups)
media1=alpha[i]+resto.media
lprob.exist=colSums(dnorm(omega1,mean=media1,sd=1,log=T))+log(theta)
#if group does not exist
p1=q1
p2=q2s[i]
mu=Sigma.precalc%*%q4s[,i]
p3=-t(mu)%*%InvSigma.precalc%*%mu
p4=-lds
p5=q3k[j]
lprob.not.exist=-(1/2)*(p1+p2+p3+p4+p5)
#which groups exist and which don't
tab=rep(0,ngroups)
tmp=table(cs)
tab[as.numeric(names(tmp))]=tmp
p1=q1
p2=q2s[i]
mu=Sigma.precalc%*%q4s[,i]
p3=-t(mu)%*%InvSigma.precalc%*%mu
p4=-lds
p5=q3k
lprob.not.exist=-(1/2)*(p1+p2+p3+p4+p5)
p1
p2
p3
p4
p5
p1=q1
p2=q2s[i]
mu=Sigma.precalc%*%q4s[,i]
p3=-t(mu)%*%InvSigma.precalc%*%mu; p3=as.numeric(p3)
p4=-lds
p5=q3k
lprob.not.exist=-(1/2)*(p1+p2+p3+p4+p5)
tab=rep(0,ngroups)
tmp=table(cs)
tab[as.numeric(names(tmp))]=tmp
lprob=rep(NA,ngroups)
cond=which(tab==0)
lprob[ cond]=lprob.not.exist
lprob[!cond]=lprob.exist[!cond]
lprob
tab
cond
lprob=rep(NA,ngroups)
cond=tab==0
lprob[ cond]=lprob.not.exist
lprob[!cond]=lprob.exist[!cond]
lprob
lprob.not.exist
q3k
rm(list=ls(all=TRUE))
set.seed(2)
library('mvtnorm')
library('Rcpp')
setwd('U:\\GIT_models\\git_cluster_rcurve_gamma')
source('gibbs functions.R')
sourceCpp('aux1.cpp')
source('gibbs clust response curve gamma.R')
ngroups=32
gamma=0.1
ngibbs=1000
nome=paste0('fake ',c('data ','xmat '),'sim ',ngroups,'ng','.csv')
y=data.matrix(read.csv(nome[1],as.is=T))
xmat=data.matrix(read.csv(nome[2],as.is=T))
res=gibbs.clust.response.curve(y=y,xmat=xmat,ngroups=50,
ngibbs=ngibbs,burnin=ngibbs/2)
rm(list=ls(all=TRUE))
set.seed(2)
library('mvtnorm')
library('Rcpp')
setwd('U:\\GIT_models\\git_cluster_rcurve_gamma')
source('gibbs functions.R')
sourceCpp('aux1.cpp')
source('gibbs clust response curve gamma.R')
ngroups=32
gamma=0.1
ngibbs=100
nome=paste0('fake ',c('data ','xmat '),'sim ',ngroups,'ng','.csv')
y=data.matrix(read.csv(nome[1],as.is=T))
xmat=data.matrix(read.csv(nome[2],as.is=T))
res=gibbs.clust.response.curve(y=y,xmat=xmat,ngroups=50,
ngibbs=ngibbs,burnin=ngibbs/2)
res$theta
dim(res$theta)
theta=res$theta[nrow(res$theta),]
plot(theta,type='h')
theta=res$theta[nrow(res$theta),]
plot(theta,type='h')
sum(theta>0.001)
sum(theta>0.01)
rm(list=ls(all=TRUE))
set.seed(2)
library('mvtnorm')
library('Rcpp')
setwd('U:\\GIT_models\\git_cluster_rcurve_gamma')
source('gibbs functions.R')
sourceCpp('aux1.cpp')
source('gibbs clust response curve gamma.R')
ngroups=32
ngibbs=1000
nome=paste0('fake ',c('data ','xmat '),'sim ',ngroups,'ng','.csv')
y=data.matrix(read.csv(nome[1],as.is=T))
xmat=data.matrix(read.csv(nome[2],as.is=T))
res=gibbs.clust.response.curve(y=y,xmat=xmat,ngroups=50,
ngibbs=ngibbs,burnin=ngibbs/2)
ngroups=50
burnin=ngibbs/2
t.xmat=t(xmat)
xtx=t.xmat%*%xmat
#useful stuff
nloc=nrow(y)
nspp=ncol(y)
nparam=ncol(xmat)
gamma.possib=seq(from=0.1,to=1,by=0.05)
#get invSigma, Sigma, lds for different values of n_k
InvSigma.precalc=xtx+diag(1,nparam)
Sigma.precalc=solve(InvSigma.precalc)
lds=determinant(Sigma.precalc)$modulus[1] #log of determinant of covariance matrix
#initial parameter values
betas=matrix(0,nparam,ngroups)
alpha=rep(0,nspp)
omega=matrix(-1,nloc,nspp)
omega[y==1]=1
cs=sample(1:ngroups,size=nspp,replace=T)
theta=rep(1/ngroups,ngroups)
gamma=0.1
#gibbs stuff
vec.betas=matrix(NA,ngibbs,nparam*ngroups)
vec.alpha=matrix(NA,ngibbs,nspp)
vec.theta=matrix(NA,ngibbs,ngroups)
vec.logl=matrix(NA,ngibbs,1)
vec.gamma=rep(NA,ngibbs,1)
vec.cs=matrix(NA,ngibbs,nspp)
i=1
print(i)
cs=sample.cs(ngroups=ngroups,omega=omega,xmat=xmat,alpha=alpha,betas=betas,theta=theta,
nspp=nspp,nloc=nloc,InvSigma.precalc=InvSigma.precalc,
Sigma.precalc=Sigma.precalc,lds=lds,cs=cs,nparam=nparam)
# cs=cs.true
betas=sample.betas(ngroups=ngroups,cs=cs,nparam=nparam,xtx=xtx,t.xmat=t.xmat,alpha=alpha,
nloc=nloc,nspp=nspp,omega=omega)
# betas=cbind(betas.true,matrix(0,nparam,ngroups-ncol(betas.true)))
omega=sample.omega(y=y,nspp=nspp,nloc=nloc,xmat=xmat,betas=betas,cs=cs,alpha=alpha)
# omega=omega.true
alpha=sample.alpha(nloc=nloc,xmat=xmat,betas=betas,omega=omega,cs=cs,nspp=nspp)
# alpha=alpha.true
tmp=sample.theta(cs=cs,ngroups=ngroups,gamma=gamma,burnin=burnin,gibbs.step=i,
betas=betas,theta=theta)
betas=tmp$betas
cs=tmp$cs
theta=tmp$theta
v=tmp$v[-ngroups]
# theta=rep(1/ngroups,ngroups)
gamma=sample.gamma(v=v,ngroups=ngroups,gamma.possib=gamma.possib)
logl=get.logl(y=y,omega=omega,nspp=nspp,nloc=nloc,xmat=xmat,betas=betas,cs=cs,alpha=alpha)
#store results
vec.betas[i,]=betas
vec.alpha[i,]=alpha
vec.theta[i,]=theta
vec.logl[i]=logl
vec.cs[i,]=cs
vec.gamma[i]=gamma
q1=nloc*log(2*pi)
alpha1=matrix(alpha,nloc,nspp,byrow=T)
err=omega-alpha1
q2s=colSums(err^2)
ltheta=log(theta)
q3k=-2*ltheta
q4s=t(xmat)%*%err
resto.media=xmat%*%betas
#for each species
for (i in 1:nspp){
#lprob if group exists
omega1=matrix(omega[,i],nloc,ngroups)
media1=alpha[i]+resto.media
lprob.exist=colSums(dnorm(omega1,mean=media1,sd=1,log=T))+ltheta
#lprob if group does not exist
p1=q1
p2=q2s[i]
mu=Sigma.precalc%*%q4s[,i]
p3=-t(mu)%*%InvSigma.precalc%*%mu; p3=as.numeric(p3)
p4=-lds
p5=q3k
lprob.not.exist=-(1/2)*(p1+p2+p3+p4+p5)
#which groups exist and which don't?
tab=rep(0,ngroups)
tmp=table(cs)
tab[as.numeric(names(tmp))]=tmp
#get probabilities for each group
lprob=rep(NA,ngroups)
cond=tab==0
lprob[ cond]=lprob.not.exist[cond]
lprob[!cond]=lprob.exist[!cond]
#normalize probabilities
max1=max(lprob)
tmp=lprob-max1
tmp1=exp(tmp)
prob=tmp1/sum(tmp1)
#sample cs
ind=rmultinom(1,size=1,prob)
ind1=which(ind==1)
cs[i]=ind1
}
cs
i=1
omega1=matrix(omega[,i],nloc,ngroups)
media1=alpha[i]+resto.media
lprob.exist=colSums(dnorm(omega1,mean=media1,sd=1,log=T))+ltheta
#lprob if group does not exist
p1=q1
p2=q2s[i]
mu=Sigma.precalc%*%q4s[,i]
p3=-t(mu)%*%InvSigma.precalc%*%mu; p3=as.numeric(p3)
p4=-lds
p5=q3k
lprob.not.exist=-(1/2)*(p1+p2+p3+p4+p5)
#which groups exist and which don't?
tab=rep(0,ngroups)
tmp=table(cs)
tab[as.numeric(names(tmp))]=tmp
#get probabilities for each group
lprob=rep(NA,ngroups)
cond=tab==0
lprob[ cond]=lprob.not.exist[cond]
lprob[!cond]=lprob.exist[!cond]
#normalize probabilities
max1=max(lprob)
tmp=lprob-max1
tmp1=exp(tmp)
prob=tmp1/sum(tmp1)
#sample cs
ind=rmultinom(1,size=1,prob)
ind1=which(ind==1)
cs[i]=ind1
nspp
rm(list=ls(all=TRUE))
set.seed(2)
library('mvtnorm')
library('Rcpp')
setwd('U:\\GIT_models\\git_cluster_rcurve_gamma')
source('gibbs functions.R')
sourceCpp('aux1.cpp')
source('gibbs clust response curve gamma.R')
ngroups=32
ngibbs=1000
nome=paste0('fake ',c('data ','xmat '),'sim ',ngroups,'ng','.csv')
y=data.matrix(read.csv(nome[1],as.is=T))
xmat=data.matrix(read.csv(nome[2],as.is=T))
res=gibbs.clust.response.curve(y=y,xmat=xmat,ngroups=50,
ngibbs=ngibbs,burnin=ngibbs/2)
